<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.8" xml:lang="en-US">
  <compounddef id="md_build_2md__files_2docs_2observer" kind="page">
    <compoundname>md_build_2md__files_2docs_2observer</compoundname>
    <title>Observer Pattern in C++</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><anchor id="md_build_2md__files_2docs_2observer_1autotoc_md87"/></para>
<para>The <bold>Observer pattern</bold> is a behavioral design pattern that defines a one-to-many dependency between objects. When one object (the subject) changes state, all of its dependents (observers) are automatically notified and updated. This pattern is particularly useful for implementing event-driven programming, where various components need to react to changes or events in a decoupled manner.</para>
<sect1 id="md_build_2md__files_2docs_2observer_1autotoc_md88">
<title>Overview</title>
<sect2 id="md_build_2md__files_2docs_2observer_1autotoc_md89">
<title>Key Concepts</title>
<para><itemizedlist>
<listitem><para><bold>Subject:</bold> <linebreak/>
 The object that holds the state and sends notifications to its observers when its state changes.</para>
</listitem><listitem><para><bold>Observer:</bold> <linebreak/>
 The object that subscribes to the subject to receive updates. Observers implement a common interface, ensuring that the subject can notify all of them in a uniform manner.</para>
</listitem><listitem><para><bold>Decoupling:</bold> <linebreak/>
 The Observer pattern promotes loose coupling between the subject and the observers. The subject does not need to know the concrete classes of its observers, only that they adhere to a common interface.</para>
</listitem></itemizedlist>
</para>
</sect2>
</sect1>
<sect1 id="md_build_2md__files_2docs_2observer_1autotoc_md90">
<title>Benefits</title>
<para><itemizedlist>
<listitem><para><bold>Modularity:</bold> <linebreak/>
 Observers can be added or removed without modifying the subject, making the system more maintainable and extensible.</para>
</listitem><listitem><para><bold>Scalability:</bold> <linebreak/>
 Multiple observers can react to changes in the subject, allowing the system to scale as new functionality is added.</para>
</listitem><listitem><para><bold>Flexibility:</bold> <linebreak/>
 Changes to the subject or observers can be made independently, as long as the interface contract is maintained.</para>
</listitem></itemizedlist>
</para>
</sect1>
<sect1 id="md_build_2md__files_2docs_2observer_1autotoc_md91">
<title>When to Use the Observer Pattern</title>
<para><itemizedlist>
<listitem><para>When a change to one object requires changing others, and you do not know how many objects need to be changed.</para>
</listitem><listitem><para>When an object should be able to notify other objects without making assumptions about who those objects are.</para>
</listitem><listitem><para>In implementing event-driven architectures where various parts of the application react to events generated by a single source.</para>
</listitem></itemizedlist>
</para>
</sect1>
<sect1 id="md_build_2md__files_2docs_2observer_1autotoc_md92">
<title>Example Implementation</title>
<para>Below is a simple example in C++ that demonstrates the Observer pattern:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>observer.hpp</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>OBSERVER_HPP</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>OBSERVER_HPP</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;string_view&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Observer<sp/>interface</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">IObserver<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/>~IObserver()<sp/>=<sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>onNotify(std::string_view<sp/>message)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>OBSERVER_HPP</highlight></codeline>
</programlisting></para>
<para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>subject.hpp</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>SUBJECT_HPP</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>SUBJECT_HPP</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="observer_8hpp" kindref="compound">observer.hpp</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;vector&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">Subject<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>addObserver(IObserver*<sp/><ref refid="namespaceobserver" kindref="compound">observer</ref>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>observers.push_back(<ref refid="namespaceobserver" kindref="compound">observer</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>removeObserver(IObserver*<sp/><ref refid="namespaceobserver" kindref="compound">observer</ref>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>observers.erase(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::remove(observers.begin(),<sp/>observers.end(),<sp/><ref refid="namespaceobserver" kindref="compound">observer</ref>),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>observers.end()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>notify(std::string_view<sp/>message)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal">*<sp/><ref refid="namespaceobserver" kindref="compound">observer</ref><sp/>:<sp/>observers)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespaceobserver" kindref="compound">observer</ref>-&gt;onNotify(message);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;IObserver*&gt;<sp/>observers;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>SUBJECT_HPP</highlight></codeline>
</programlisting></para>
<para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>concrete_observer.hpp</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>CONCRETE_OBSERVER_HPP</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>CONCRETE_OBSERVER_HPP</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="observer_8hpp" kindref="compound">observer.hpp</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal"><ref refid="classConcreteObserver" kindref="compound">ConcreteObserver</ref><sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>IObserver<sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="classConcreteObserver_1aebc85755ca3d5640fc2473da96c2b4d6" kindref="member">onNotify</ref>(std::string_view<sp/>message)</highlight><highlight class="keyword"><sp/>override<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;ConcreteObserver<sp/>received:<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>message<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>CONCRETE_OBSERVER_HPP</highlight></codeline>
</programlisting></para>
<para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>main.cpp</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="subject_8hpp" kindref="compound">subject.hpp</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;concrete_observer.hpp&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="callbacks_2main_8cpp_1ae66f6b31b5ad750f1fe042a706a4e3d4" kindref="member">main</ref>()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Subject<sp/>subject;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classConcreteObserver" kindref="compound">ConcreteObserver</ref><sp/>observer1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classConcreteObserver" kindref="compound">ConcreteObserver</ref><sp/>observer2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Register<sp/>observers</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>subject.addObserver(&amp;observer1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>subject.addObserver(&amp;observer2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Notify<sp/>all<sp/>observers</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>subject.notify(</highlight><highlight class="stringliteral">&quot;Event<sp/>occurred!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Removing<sp/>an<sp/>observer<sp/>and<sp/>notifying<sp/>again</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>subject.removeObserver(&amp;observer1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>subject.notify(</highlight><highlight class="stringliteral">&quot;Another<sp/>event<sp/>occurred!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect1>
<sect1 id="md_build_2md__files_2docs_2observer_1autotoc_md93">
<title>How It Works</title>
<para><orderedlist>
<listitem><para><bold>Subject Setup:</bold> <linebreak/>
 The <computeroutput>Subject</computeroutput> class maintains a list of observers. It provides methods to add, remove, and notify observers when an event occurs.</para>
</listitem><listitem><para><bold>Observer Implementation:</bold> <linebreak/>
 The <computeroutput>IObserver</computeroutput> interface defines a contract (<computeroutput>onNotify</computeroutput>) that all observers must implement. In this example, <computeroutput><ref refid="classConcreteObserver" kindref="compound">ConcreteObserver</ref></computeroutput> implements this interface and defines the reaction to notifications.</para>
</listitem><listitem><para><bold>Notification Mechanism:</bold> <linebreak/>
 When the subject&apos;s <computeroutput>notify</computeroutput> method is called, it iterates over all registered observers and calls their <computeroutput>onNotify</computeroutput> method, passing along the event message.</para>
</listitem></orderedlist>
</para>
</sect1>
<sect1 id="md_build_2md__files_2docs_2observer_1autotoc_md94">
<title>Conclusion</title>
<para>The Observer pattern is a foundational component of event-driven programming in C++. It allows for flexible and decoupled system designs where components can react to events dynamically. By leveraging this pattern, you can create applications that are easier to maintain, extend, and test.</para>
<para>Feel free to extend this example or integrate it into your project to handle more complex event notifications and interactions. </para>
</sect1>
    </detaileddescription>
    <location file="build/md_files/docs/observer.md"/>
  </compounddef>
</doxygen>
